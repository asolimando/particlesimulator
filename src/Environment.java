import java.util.*;

/**
 * The working environment is a rectangular area of the plane which
 * contains a certain number of particles of the three existing types.
 */

public class Environment
{

  /* CLASS ATTRIBUTES */

  /* constants for denoting the four walls of the environment */

  /** symbolic name for top (i.e., maximum y) wall */
  public static final int TOP = 0;
  /** symbolic name for bottom (i.e., minimum y) wall */
  public static final int BOTTOM = 1;
  /** symbolic name for left (i.e., minimum x) wall */
  public static final int LEFT = 2;
  /** symbolic name for right (i.e., maximum x) wall */
  public static final int RIGHT = 3;

  /* extra values for particle history (for temporary, auxiliary use) */
  private static final int DELETED = 100;
  private static final int UNKNOWN = 200;

  /* INSTANCE ATTRIBUTES */

  /* boundaries of the environment */
  private double maxX, minX, maxY, minY;

  /* rotation angle for new particles after a split (in radiants) */
  private double A = 0.5;

  /* java vector containing all particles */
  private Vector allParticles;

  /* error message of the last failed operation */
  private String errorMsg;

  /* INSTANCE METHODS */

  /** Return error message generated by the last failed operation. */
  public String lastErrorMsg() { return errorMsg; }

  /** Create a working environment of given boundaries.
   * @param     x0  minimum x, i.e., x of left wall
   * @param     y0  mimimum y, i.e., y of bottom wall
   * @param     x1  maximum x, i.e., x of right wall
   * @param     y1  maximum y, i.e., y of top wall
   */
  public Environment(double x0, double y0, double x1, double y1)
  {
    minX = x0; minY = y0; maxX = x1; maxY = y1;
    allParticles = new Vector(200,100);
  }

  /** Make a given sub-area empty by deleting all particles in it.
   * @param     x0  minimum x of area to be emptied
   * @param     y0  mimimum y of area to be emptied
   * @param     x1  maximum x of area to be emptied
   * @param     y1  maximum y of area to be emptied
   */
  public void emptyArea(double x0, double y0, double x1, double y1)
  {
    int i;
    Particle bi;
    double r;
    for (i=allParticles.size()-1; i>=0; i--)
    {
      bi = getParticle(i);
      r = bi.getRadius();
      if ( ( ( (bi.getCenter().x-r)<x1 ) && ( (bi.getCenter().y-r)<y1 ) )
           &&
           ( ( (bi.getCenter().x+r)>x0 ) && ( (bi.getCenter().y+r)>y0 ) ) )
      {  removeParticle(bi);   }
    }
  }

  /* get the limits of the rectangle defining the working area */
  /** Get the minimum x of this environment (left wall). */
  public double getMinX() {  return minX;  }
  /** Get the minimum y of this environment (bottom wall). */
  public double getMinY() {  return minY;  }
  /** Get the maximum x of this environment (right wall). */
  public double getMaxX() {  return maxX;  }
  /** Get the maximum y of this environment (top wall). */
  public double getMaxY() {  return maxY;  }

  /** Set the limits of the environment, failure if a
   *  minimum coordinate is larger than a maximum coordinate,
   *  or not all particles are inside the new area.
   *  Return true if success, false if failure.
   * @param     x0  new minimum x 
   * @param     y0  new mimimum y
   * @param     x1  new maximum x 
   * @param     y1  new maximum y
   */
  public boolean setBoundary(double x0, double y0, double x1, double y1)
  {
    errorMsg = "";
    if ( (x0>minX) || (y0>minY) || (x1<maxX) || (y1<maxY) )
    {
      int i;
      if ( (allParticles.size()>0) && (!isEmptyOutside(x0,y0, x1,y1)) )
      {  errorMsg = "ERROR(setBoundary): some particles are outside new environment";
         return false;
      }
    }
    minX = x0; minY = y0; maxX = x1; maxY = y1;
    return true;
  }

  /* return the normal vector to the given wall,
     wall must be one of TOP, BOTTOM, LEFT, RIGHT */
  private PairOfDouble wallNormal(int wall)
  {
    switch(wall)
    {
      case TOP:    return new PairOfDouble(0,-1);
      case BOTTOM: return new PairOfDouble(0,1);
      case LEFT:   return new PairOfDouble(1,0);
      case RIGHT:  return new PairOfDouble(-1,0);
    }
    return null; /* this should never happen */
  }

  /** Return number of particles in the enviromnent. */
  public int getNumber() {  return allParticles.size();  }

  /** Add a particle to the environment, failure if the particle 
   *  is not inside the environment.
   *  Return true if success, false if failure.
   * @param     b  the particle to be added
   */
  public boolean addParticle(Particle b)
  {
    errorMsg = "";
    if ((b==null) || !b.isTotalInside(minX,minY, maxX,maxY))
    {  errorMsg = "ERROR(addParticle): particle is not totally inside";
       return false;
    }
    return allParticles.add(b);
  }

  /** Get the i-th particle in the enviromnent, null if i is
   *  larger than the number of particles.
   * @param     i  index of particle to be returned
   */
  public Particle getParticle(int i)
  {
     if ( (i>=0) && (i<allParticles.size()) )
       return (Particle)allParticles.elementAt(i);
     else return null;
  }

  /** Remove a particle from the enviroment, if it was present.
   *  Return true if success, false if failure.
   * @param     b  the particle to be removed
   */
  public boolean removeParticle(Particle b)
  {  return allParticles.remove(b);  } 

  /* return the position of the center of the given particle after
     one unit of time (one step of the simulation) */
  private PairOfDouble nextCenter(Particle b)
  {
    PairOfDouble r = new PairOfDouble(b.getCenter());
    r.translate( b.getSpeed() );
    return r;
  }

  /* return true if the given particle hits the given wall of the
     working area, wall must be one of TOP, BOTTOM, LEFT, RIGHT */
  private boolean hitWall(Particle b, int wall)
  {
    switch(wall)
    {
      case TOP: 
        return ( (b.getCenter().y+b.getRadius()) >= maxY );
      case BOTTOM:
        return ( (b.getCenter().y-b.getRadius()) <= minY );
      case LEFT:
        return ( (b.getCenter().x-b.getRadius()) <= minX );
      case RIGHT:
        return ( (b.getCenter().x+b.getRadius()) >= maxX );
    }
    return false;
  }

  /** Advance one unit of time, i.e., one step, in the simulation. */
  public void moveOneStep()
  {
    Vector newParticles = new Vector(allParticles.size()/10,10);
    Particle bi, bj, b;
    int i, j, w;

    /* move to new location and reflect in case of wall hit */
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      bi.setCenter(nextCenter(bi));
      bi.setHistory(UNKNOWN);
      for (w=0; w<4; w++)
        if ( hitWall(bi,w) )
        {
           bi.setDirection( bi.reflectDirection(wallNormal(w)) );
           bi.setHistory(Particle.BORDER);
        }
    }

    /* check hits between pairs of single particles: 
       if hit, then merge two simple particles into a double one */
    for (i=0; i<allParticles.size(); i++)
    for (j=0; j<allParticles.size(); j++)
    {
      bi = getParticle(i);
      bj = getParticle(j);
      if ( (i != j) && 
           (bi.getType()==Particle.SINGLE) &&
           (bj.getType()==Particle.SINGLE) &&
           (bi.getHistory()!=DELETED) &&
           (bj.getHistory()!=DELETED) &&
           Particle.isHit(bi,bj) )
      {
         PairOfDouble c =
             PairOfDouble.midPoint(bi.getCenter(),bj.getCenter());
         PairOfDouble d =
             PairOfDouble.midPoint(bi.getDirection(),bj.getDirection());
         if ( (d.x==0.0) && (d.y==0.0) )
         {
            if (bi.getSpeedValue()>bj.getSpeedValue())
                 d = new PairOfDouble(bi.getDirection());
            else d = new PairOfDouble(bj.getDirection());
         }
         b = new Particle (Particle.DOUBLE, c, d);
         b.setHistory(Particle.MERGE);
         newParticles.add(b);
         bi.setHistory(DELETED);
         bj.setHistory(DELETED);
      }
    } // for for

    /* check hits between a double particle and a breaker:
       if hit, then split the double particle into two simple ones */
    for (i=0; i<allParticles.size(); i++)
    for (j=0; j<allParticles.size(); j++)
    {
      bi = getParticle(i);
      bj = getParticle(j);
      if ( (i != j) && 
           (bi.getType()==Particle.DOUBLE) &&
           (bj.getType()==Particle.BREAKER) &&
           (bi.getHistory()!=DELETED) &&
           Particle.isHit(bi,bj) )
      {
         bi.setDirection( bi.reflectDirection(bi.axis(bj)) );
         b = new Particle(bi);
         b.setType(Particle.SINGLE);
         b.setHistory(Particle.SPLIT);
         b.getDirection().counterclockRotate(Math.cos(A),Math.sin(A));
         b.getCenter().translate( new PairOfDouble(
                     2.0*b.getRadius()*b.getDirection().x,
                     2.0*b.getRadius()*b.getDirection().y) );
         newParticles.add(b);
         b = new Particle(bi);
         b.setType(Particle.SINGLE);
         b.setHistory(Particle.SPLIT);
         b.getDirection().counterclockRotate(Math.cos(-A),Math.sin(-A));
         b.getCenter().translate( new PairOfDouble(
                  2.0*b.getRadius()*b.getDirection().x,
                  2.0*b.getRadius()*b.getDirection().y) );
         newParticles.add(b);
         bi.setHistory(DELETED);
      }
    } // for for

    /* delete old particles, add new particles */
    for (i=allParticles.size()-1; i>=0; i--)
    {
      bi = getParticle(i);
      if (bi.getHistory() == DELETED) allParticles.removeElementAt(i);
      else if (bi.getHistory() == UNKNOWN) bi.setHistory(Particle.PLAIN);
    }
    for (i=0; i<newParticles.size(); i++)
       allParticles.add( newParticles.elementAt(i) );

    /* check hits between particles: if hit, then reflect */
    for (i=0; i<allParticles.size(); i++)
    for (j=0; j<allParticles.size(); j++)
    {
      bi = getParticle(i);
      bj = getParticle(j);
      if ( (i != j) && 
           Particle.isHit(bi,bj) )
      {
         bi.setDirection( bi.reflectDirection(bi.axis(bj)) );
         if (bi.getHistory()==Particle.PLAIN)
             bi.setHistory(Particle.REFLECT);
      }
    } // for for

    /* make sure there aren't particles (partially) outside the walls */
    for (i=0; i<allParticles.size(); i++)
    {
      Particle particle = getParticle(i);
      PairOfDouble center = particle.getCenter();
      double radius = particle.getRadius();
      if (center.x - radius < minX) center.x = minX + radius;
      if (center.x + radius > maxX) center.x = maxX - radius;
      if (center.y - radius < minY) center.y = minY + radius;
      if (center.y + radius > maxY) center.y = maxY - radius;
      particle.setCenter(center);
    }

  }

  /** Attract all the directions of particle speeds towards a
   *  given point, with a given percentage of attraction.
   * @param     a   position of the point attractor
   * @param     percent   percentage of attraction
   */
  public void attract(PairOfDouble a, int percent)
  {
    int i;
    Particle bi;
    PairOfDouble d;
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      d = new PairOfDouble(a.x-bi.getCenter().x, a.y-bi.getCenter().y);
      d.normalize();
      attract(bi,d,0.01*(double)percent);
    }
  }

  /** Attract all the directions of particle speeds towards a given
   *  wall, with a given percentage of attraction.
   * @param     w   symbolic name of the wall,
   *                one of TOP, BOTTOM, LEFT, RIGHT
   * @param     percent   percentage of attraction
   */
  public void attract(int w, int percent)
  {
    int i;
    Particle bi;
    PairOfDouble d = wallNormal(w);
    d.scale(-1);
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      attract(bi,d,0.01*(double)percent);
    }
  }

  /** Attract all the directions of particle speeds, for particles
   *  of given type, towards a given point, with a given percentage
   *  of attraction.
   * @param     a   position of the point attractor
   * @param     percent   percentage of attraction
   * @param     type  type of particles to be attracted, one of
   *                Particle.SINGLE, Particle.DOUBLE, Particle.BREAKER
   */
  public void attract(PairOfDouble a, int percent, int type)
  {
    int i;
    Particle bi;
    PairOfDouble d;
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      if (bi.getType() == type)
      { 
        d = new PairOfDouble(a.x-bi.getCenter().x, a.y-bi.getCenter().y);
        d.normalize();
        attract(bi,d,0.01*(double)percent);
      }
    }
  }

  /** Attract all the directions of particle speeds for particles
   *  of given type, towards a given wall, with a given percentage
   *  of attraction.
   * @param     w   symbolic name of the wall,
   *                one of TOP, BOTTOM, LEFT, RIGHT
   * @param     percent   percentage of attraction
   * @param     type  type of particles to be attracted, one of
   *                Particle.SINGLE, Particle.DOUBLE, Particle.BREAKER
   */
  public void attract(int w, int percent, int type)
  {
    int i;
    Particle bi;
    PairOfDouble d = wallNormal(w);
    d.scale(-1);
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      if (bi.getType() == type)
        attract(bi,d,0.01*(double)percent);
    }
  }

  /* attract a particle towards a given direction */
  private void attract(Particle b, PairOfDouble d, double quota)
  {
    double vx = (1.0-quota)*b.getDirection().x + (quota)*d.x;
    double vy = (1.0-quota)*b.getDirection().y + (quota)*d.y;
    b.setDirection( new PairOfDouble(vx,vy) );
  }

  /** Check whether a given sub-area is empty (i.e., no particle in it).
   * @param     x0  minimum x of area to be checked
   * @param     y0  mimimum y of area to be checked
   * @param     x1  maximum x of area to be checked
   * @param     y1  maximum y of area to be checked
   */
  public boolean isEmptyArea(double x0, double y0, double x1, double y1)
  {
    int i;
    Particle bi;
    double r;
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      r = bi.getRadius();
      if ( ( (bi.getCenter().x-r)<x1 ) && ( (bi.getCenter().y-r)<y1 ) 
            &&
           ( (bi.getCenter().x+r)>x0 ) && ( (bi.getCenter().y+r)>y0 ) )
         return false;
    }
    return true;
  }

  /** Check whether the space outside a given sub-area is empty
   *  (i.e., it contains no particle).
   * @param     x0  minimum x of area 
   * @param     y0  mimimum y of area 
   * @param     x1  maximum x of area 
   * @param     y1  maximum y of area
   */
  public boolean isEmptyOutside(double x0, double y0, double x1, double y1)
  {
    int i;
    Particle bi;
    double r;
    for (i=0; i<allParticles.size(); i++)
    {
      bi = getParticle(i);
      r = bi.getRadius();
      if (bi.isPartOutside(x0,y0, x1,y1)) return false;
    }
    return true;
  }

  /** Fill a given sub-area with a mix of particles of the three types,
   *  according to the given percentages, the sub-area must be empty,
   *  and the sum of percentages must be 100.
   *  Return true if success, false if failure.
   * @param     x0  minimum x of area to be filled
   * @param     y0  mimimum y of area to be filled
   * @param     x1  maximum x of area to be filled
   * @param     y1  maximum y of area to be filled
   * @param     percent1 percentage of particles of the first type 
   * @param     percent2 percentage of particles of the second type 
   * @param     percent3 percentage of particles of third type
   */
  /*
  ALGORITMO:
  Sovrappone all'area una griglia di quadrati con lato pari a 2 volte
  il max diametro dei tipi di particelle da mettere.
  In ogni quadrato mettera' una particella scegliendone a caso il tipo
  fra i tre (nel vincolo che le percentuali siano rispettate) e 
  piazzandola a caso all'interno del quadrato (purche' interamente
  contenuta nel quadrato).
  */
  public boolean fillArea(double x0, double y0, double x1, double y1,
                          int percent1, int percent2, int percent3)
  {
    errorMsg = "";
    if ((percent1+percent2+percent3) != 100)
    {  errorMsg = "ERROR(fillArea): sum of percentages is not 100.";
       return false;
    }
    if (!isEmptyArea(x0,y0,x1,y1))
    {  errorMsg = "ERROR(fillArea): area to be filled is not empty.";
       return false;
    }
    double gridEdge = 0.0;
    if ( (percent1>0) &&
         (Particle.getRadius(Particle.SINGLE)>gridEdge) )
       gridEdge = Particle.getRadius(Particle.SINGLE);
    if ( (percent2>0) &&
         (Particle.getRadius(Particle.DOUBLE)>gridEdge) )
       gridEdge = Particle.getRadius(Particle.DOUBLE);
    if ( (percent3>0) &&
         (Particle.getRadius(Particle.BREAKER)>gridEdge) )
       gridEdge = Particle.getRadius(Particle.BREAKER);
    gridEdge *= 3.0; 
    int gridRows = (int)( (y1-y0) / gridEdge );
    int gridCols = (int)( (x1-x0) / gridEdge );
    int num = gridRows * gridCols; /* numero particelle da inserire */
    int r,c;
    int num1, num2, num3;
    num1 = (int) ( num* ((double)percent1/100.0) );
    num2 = (int) ( num* ((double)percent2/100.0) );
    num3 = (int) ( num* ((double)percent3/100.0) );
    /* numero di particelle da aggiungere, inizialmente puo' essere
       < 100 causa arrotondamenti, e decresce man mano che aggiungo */
    int numToAdd = num1 + num2 + num3; 
    double x, y;
    Particle b;
    int t;
    int anyNumber;
    for (r=0; (numToAdd>0) && (r<gridRows); r++)
    for (c=0; (numToAdd>0) && (c<gridCols); c++)
    {
      anyNumber = (int)(Math.random() * (double)(numToAdd));
      if (anyNumber < num1) {  t = Particle.SINGLE; num1--;  }
      else if (anyNumber < num1+num2) {  t = Particle.DOUBLE; num2--;  }
           else {  t = Particle.BREAKER; num3--;  }
      x = x0 + c*gridEdge + Particle.getRadius(t) +
          Math.random() * ( gridEdge-2.0*Particle.getRadius(t) );
      y = y0 + r*gridEdge + Particle.getRadius(t) +
          Math.random() * ( gridEdge-2.0*Particle.getRadius(t) );
      b = new Particle(t,x,y,
                       -1.0+2.0*Math.random(),-1.0+2.0*Math.random());
      addParticle(b);
      numToAdd--;
    }
    if ( (num1>0) || (num2>0) || (num3>0) ) /* non dovrebbe succedere */
    {  errorMsg = "ERROR(fillArea): particelle non aggiunte " + num1 + " " + num2 + " " + num3;
       return false; 
    }
    return true;
  }

}